{
  "comments": [
    {
      "key": {
        "uuid": "1c8a26d7_a7c9d399",
        "filename": "lockmanager/lockmanager-impl/src/main/java/org/opendaylight/genius/lockmanager/impl/LockManagerServiceImpl.java",
        "patchSetId": 1
      },
      "lineNbr": 229,
      "author": {
        "id": 5867
      },
      "writtenOn": "2018-07-26T12:10:43Z",
      "side": 0,
      "message": "if I understand the flow in this code correctly, then loosing this cancel() is not a problem here - but it would be good if others could look this over to confirm.",
      "revId": "d16c602102f05c11a8810d0f3fd2aae5e65e20e0",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "df3a61e1_e95cfeed",
        "filename": "lockmanager/lockmanager-impl/src/main/java/org/opendaylight/genius/lockmanager/impl/LockManagerServiceImpl.java",
        "patchSetId": 1
      },
      "lineNbr": 229,
      "author": {
        "id": 7615
      },
      "writtenOn": "2018-07-27T06:14:02Z",
      "side": 0,
      "message": "This cancel() prevents memory leakage if lock on the same lock object is already acquired by some other thread.\n\nAs RetryingManagedNewTransactionRunner always submits the transaction, which will unnecessary create transaction overhead in the above case, where submitting the transaction is not required. If this is ok? Then fine for me.",
      "parentUuid": "1c8a26d7_a7c9d399",
      "revId": "d16c602102f05c11a8810d0f3fd2aae5e65e20e0",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ddee0684_ed21c7ac",
        "filename": "lockmanager/lockmanager-impl/src/main/java/org/opendaylight/genius/lockmanager/impl/LockManagerServiceImpl.java",
        "patchSetId": 1
      },
      "lineNbr": 229,
      "author": {
        "id": 5867
      },
      "writtenOn": "2018-07-27T09:24:36Z",
      "side": 0,
      "message": "\u003e This cancel() prevents memory leakage if \n\nright, but with RetryingManagedNewTransactionRunner always doing a submit() there won\u0027t ever be any leaks either, so not a problem from this PoV.\n\n\u003e As RetryingManagedNewTransactionRunner always submits the transaction, which will unnecessary create transaction overhead in the above case, where submitting the transaction is not required. If this is ok? Then fine for me.\n\nI see what you mean.  But in this case it would submit a Tx which has no put on it.  Surely the implementation is smart enough to just do nothing in this case (what should it do, there is nothing to do).  So I think this is fine.  In theory I gues RetryingManagedNewTransactionRunner could be made smarter and itself track if no put etc. was ever made on it and then cancel instead of submit, but that seems like a premature optimization to me.  I\u0027ll email controller-dev and mdsal-dev to ask about this though.  If this explanation is OK for you, can you +1 this so that we can get it in ASAP (code freeze next week!).",
      "parentUuid": "df3a61e1_e95cfeed",
      "revId": "d16c602102f05c11a8810d0f3fd2aae5e65e20e0",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    }
  ]
}